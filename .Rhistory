install.packages("ggmap")
# Load required packages
library(ggmap)
# Set the address or coordinates for the location of interest
address <- "1600 Amphitheatre Parkway, Mountain View, CA"
# Retrieve the latitude and longitude of the address
location <- geocode(address)
nearby_places <- ggmap::nearby(location = location, radius = 500, type = c("establishment"))
install.packages("mapsapi")
library(maps)
library(mapsapi)
# Load required packages
library(ggmap)
library(mapsapi)
# Set the address or coordinates for the location of interest
address <- "1600 Amphitheatre Parkway, Mountain View, CA"
# Retrieve the latitude and longitude of the address
location <- geocode(address)
# Set the address or coordinates for the location of interest
address <- "1600 Amphitheatre Parkway, Mountain View, CA"
# Retrieve the latitude and longitude of the address
location <- geocode(address)
# Retrieve the latitude and longitude of the address
location <- ggmap::geocode(address)
nearby_places <- mapsapi::nearby(location = location, radius = 500, type = c("establishment"))
install.packages("osmdata")
install.packages("ggplot2")
install.packages("ggplot2")
library(osmdata)
library(ggplot2)
location <- c(lat = 51.5074, lon = -0.1278)
query <- opq(bbox_from_point(location), timeout = 25)
location <- "1600 Amphitheatre Parkway, Mountain View, CA"
query <- opq(bbox_to_string(location), timeout = 25)
library(tmaptools)
install.packages("tmaptools")
library(tmaptools)
library(httr)
library(jsonlite)
library(RCurl)
install.packages("leaflet")
library(osmdata)
library(leaflet)
# Define the location
location <- c(lat = 40.7128, lon = -74.0060)
# Get the OpenStreetMap data
osm_data <- opq(bbox = getbb(location, radius = 1000)) %>%
add_osm_feature(key = 'place') %>%
osmdata_sf()
# Get the OpenStreetMap data
osm_data <- opq(bbox = getbb(location, radius = 1000)) %>%
add_osm_feature(key = 'place') %>%
osmdata_sf()
osm_data <- opq(bbox = getbb(location)) %>%
add_osm_feature(key = 'place') %>%
osmdata_sf()
# Get the OpenStreetMap data
osm_data <- opq(bbox = getbb(location)) %>%
add_osm_feature(key = 'place')
# Get the OpenStreetMap data
osm_data <- opq(bbox = getbb(location))
osm_data <- opq(bbox = getbb(address))
url <- "https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=-34.44076&lon=-58.70521"
dat <- jsonlite::fromJSON(url)
View(dat)
Data <- as.data.frame(dat)
View(Data)
Data <- unique(as.data.frame(dat))
View(Data)
Data <- unique(select(as.data.frame(dat), -c(boundingbox))
Data <- unique(select(as.data.frame(dat), -c(boundingbox))
View(Data)
select(as.data.frame(dat), -c(boundingbox)
select(as.data.frame(dat), -c(boundingbox)
Data <- unique(select(as.data.frame(dat), -c(boundingbox)))
Data <- unique(select(as.data.frame(dat), -c(boundingbox)))
Data <- unique(select(as.data.frame(dat), -c(boundingbox)))
Data <- unique(select(as.data.frame(dat), -c(boundingbox)))
library(dplyr)
Data <- unique(select(as.data.frame(dat), -c(boundingbox)))
url <- "https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=-34&lon=-58"
dat <- jsonlite::fromJSON(url)
Data <- unique(select(as.data.frame(dat), -c(boundingbox)))
url <- "https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=-34&lon=-58"
dat <- jsonlite::fromJSON(url)
Data <- unique(select(as.data.frame(dat), -c(boundingbox)))
url <- "https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=-34&lon=-58"
dat <- jsonlite::fromJSON(url)
View(dat)
url <- "https://nominatim.openstreetmap.org/search?q=school+budapest&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- unique(select(as.data.frame(dat), -c(boundingbox)))
View(dat)
Data <- dat$features
View(Data)
library(ggmap)
# set the latitude and longitude coordinates
lat <- 37.7749
lon <- -122.4194
# use geocode() to transform the coordinates into a geocode
geo <- geocode(paste(lat, lon, sep = ","))
geo <- geocode(location = c(lon, lat), source = "osm")
# set the latitude and longitude coordinates
lat <- 37.7749
lon <- -122.4194
geo <- geocode(location = c(lon, lat), source = "osm")
geo <- geocode(location = c(lon, lat), source = "osm")
# set the latitude and longitude coordinates
lat <- 37.7749
lon <- -122.4194
# convert the coordinates to a character string
location <- paste(lat, lon, sep = ",")
# use geocode() with OpenStreetMap data to transform the coordinates into a geocode
geo <- geocode(location = location, source = "osm")
# use geocode() with OpenStreetMap data to transform the coordinates into a geocode
geo <- geocode(location = location, source = "dsk")
# use geocode() with OpenStreetMap data to transform the coordinates into a geocode
geo <- geocode(location = location, source = "google")
# use geocode() with OpenStreetMap data to transform the coordinates into a geocode
geo <- geocode(location = location, source = "osm")
# install and load the OpenStreetMap package
library(OpenStreetMap)
# set the latitude and longitude coordinates
lat <- 37.7749
lon <- -122.4194
# retrieve OpenStreetMap data for the area around the coordinates
osm <- openmap(c(lat, lon), c(lat, lon), type = "osm")
library(OpenStreetMap)
# set the latitude and longitude coordinates
lat <- 37.7749
lon <- -122.4194
# retrieve OpenStreetMap data for the area around the coordinates
osm <- openmap(c(lat, lon), c(lat, lon), type = "osm")
osm <- openmap(c(lat, lon), c(lat, lon), type = "osm")
# set the latitude and longitude coordinates
lat <- 37.7749
lon <- -122.4194
# define the bounding box as a matrix of coordinates
bbox <- matrix(c(lon - 0.01, lat - 0.01, lon + 0.01, lat + 0.01), ncol = 2, byrow = TRUE)
# retrieve OpenStreetMap data for the bounding box
osm <- openmap(bbox, type = "osm")
lat <- 37.7749
lon <- -122.4194
# define the bounding box as a matrix of coordinates
bbox <- matrix(c(lon - 0.01, lat - 0.01, lon + 0.01, lat + 0.01), ncol = 2, byrow = TRUE)
osm <- openmap(bbox, type = "osm")
library(tidyr)
# retrieve OpenStreetMap data for the bounding box
osm <- openmap(bbox, type = "osm")
# set the latitude and longitude coordinates
lat <- 37.7749
lon <- -122.4194
# define the bounding box as a matrix of coordinates
bbox <- matrix(c(lon - 0.01, lat - 0.01, lon + 0.01, lat + 0.01), ncol = 2, byrow = TRUE)
# retrieve OpenStreetMap data for the bounding box
osm <- openmap(bbox[1, ], bbox[2, ], type = "osm")
# set the latitude and longitude coordinates
lat <- 37.7749
lon <- -122.4194
# define the bounding box as a matrix of coordinates
bbox <- matrix(c(lon - 0.01, lat - 0.01, lon + 0.01, lat + 0.01), ncol = 2, byrow = TRUE)
# retrieve OpenStreetMap data for the bounding box
osm <- openmap(bbox[1, ], bbox[2, ], type = "osm")
# retrieve OpenStreetMap data for the bounding box
osm <- openmap(bbox[1, ], bbox[2, ], type = "osm",zoom = 19)
# retrieve OpenStreetMap data for the bounding box
osm <- openmap(bbox[1, ], bbox[2, ], type = "osm",zoom = 10)
geo <- data.frame(lon = osm$bbox[1], lat = osm$bbox[2])
stall and load the OpenStreetMap package
# Encode the address for use in the URL
url_address <- URLencode(address)
url_address
url <- "https://nominatim.openstreetmap.org/search?q=school+budapest&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
View(Data)
url <- "https://nominatim.openstreetmap.org/search?q=burriana&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
View(Data)
url <- "https://nominatim.openstreetmap.org/search?q=school+burriana&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
url <- "https://nominatim.openstreetmap.org/search?q=school+univeristy+market+burriana&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
url <- "https://nominatim.openstreetmap.org/search?q=market+burriana&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
url <- "https://nominatim.openstreetmap.org/search?q=mercado+burriana&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
url <- "https://nominatim.openstreetmap.org/search?q=nuestra+seÃ±ora+de+la+consolacion+burriana&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
url <- "https://nominatim.openstreetmap.org/search?q=bucares&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
url <- "https://nominatim.openstreetmap.org/search?q=universidad+espana=geojson"
dat <- jsonlite::fromJSON(url)
url <- "https://nominatim.openstreetmap.org/search?q=universidad+espana&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
View(Data)
url <- "https://nominatim.openstreetmap.org/search?q=hilton+london+metropole&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
View(Data)
url <- "https://nominatim.openstreetmap.org/search?q=hotel+casa+accademia+venezia&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
url <- "https://nominatim.openstreetmap.org/search?q=casa+accademia+venezia&format=geojson"
dat <- jsonlite::fromJSON(url)
Data <- dat$features
library(ibeRa)
library(ibeRa)
ibeRa::finance_reconcile_sums()
library(ibeRa)
ibeRa::finance_reconcile_sums(amounts = C(1,2,3,4,5))
ibeRa::finance_reconcile_sums(amounts = c(1,2,3,4,5))
ibeRa::finance_reconcile_sums(amounts = c(1,2,3,4,5))
ibeRa::finance_reconcile_sums(amounts = c(1,2,3,4,5))
ibeRa::finance_reconcile_sums(amounts = c(1,2,3,4,5))
ibeRa::finance_reconcile_sums(amounts = c(1,2,3,4,5))
ibeRa::finance_reconcile_sums(amounts = c(1,2,3))
amounts = c(10, 20, 30, 40, 50)
transactions <- data.frame( ids = c(1:length(amounts)),
amounts = amounts  )
output <- list()
# Loop through all possible combinations of transactions
for (i in 1:nrow(transactions)) {
for (j in i:nrow(transactions)) {
for (z in j:nrow(transactions)) {
for (w in z:nrow(transactions)) {
# Calculate the sum of the amounts for this combination
sum_amount <- sum(transactions$amount[c(i:j,z:w)])
# Add the sum and the corresponding ids to the output list
output[[length(output) + 1]] <- c(sum_amount, paste(transactions$id[c(i:j,z:w)], collapse = "-"))
}
}
}
}
View(output)
finance_reconcile_sums <- function(amounts = c(10, 20, 30, 40, 50)){
# Sample input data frame
transactions <- data.frame( ids = c(1:length(amounts)),
amounts = amounts  )
# Function to generate all possible sum combinations and their corresponding ids
generate_sum_combinations <- function(transactions) {
# Create an empty list to store the output
output <- list()
# Loop through all possible combinations of transactions
for (i in 1:nrow(transactions)) {
for (j in i:nrow(transactions)) {
for (z in j:nrow(transactions)) {
for (w in z:nrow(transactions)) {
# Check that the ids are unique
if (length(unique(c(transactions$id[i:j], transactions$id[z:w]))) == length(c(transactions$id[i:j], transactions$id[z:w]))) {
# Calculate the sum of the amounts for this combination
sum_amount <- sum(transactions$amount[c(i:j,z:w)])
# Add the sum and the corresponding ids to the output list
output[[length(output) + 1]] <- c(sum_amount, paste(transactions$id[c(i:j,z:w)], collapse = "-"))
}
}
}
}
}
# Convert the output list to a data frame and return it
output_df <- data.frame(t(matrix(unlist(output), ncol = length(output))))
colnames(output_df) <- c("sum", "ids")
return(output_df)
}
# Call the function with the input data frame
output <- generate_sum_combinations(transactions)
return(output)
}
finance_reconcile_sums(amounts = c(1,2,3))
finance_reconcile_sums(amounts = c(1,2,3,4))
library(ibeRa)
finance_reconcile_sums(amounts = c(1))
finance_reconcile_sums(amounts = c(1,2))
finance_reconcile_sums(amounts = c(1,2,3))
finance_reconcile_sums <- function(transactions) {
# Create an empty list to store the output
output <- list()
# Loop through all possible combinations of transactions
for (i in 1:(nrow(transactions)-1)) {
for (j in i:nrow(transactions)) {
# Check that the ids are unique
if (length(unique(transactions$id[i:j])) == length(transactions$id[i:j])) {
# Calculate the sum of the amounts for this combination
sum_amount <- sum(transactions$amount[i:j])
# Add the sum and the corresponding ids to the output list
output[[length(output) + 1]] <- c(sum_amount, paste(transactions$id[i:j], collapse = "-"))
}
}
}
# Convert the output list to a data frame and return it
output_df <- data.frame(t(matrix(unlist(output), ncol = length(output))))
colnames(output_df) <- c("sum", "ids")
return(output_df)
}
# Call the function with the input data frame
output <- generate_sum_combinations(transactions)
finance_reconcile_sums <- function(amounts = c(10, 20, 30, 40, 50)){
# Sample input data frame
transactions <- data.frame( ids = c(1:length(amounts)),
amounts = amounts  )
# Function to generate all possible sum combinations and their corresponding ids
generate_sum_combinations <- function(transactions) {
# Create an empty list to store the output
output <- list()
# Loop through all possible combinations of transactions
for (i in 1:nrow(transactions)) {
for (j in i:nrow(transactions)) {
for (z in j:nrow(transactions)) {
for (w in z:nrow(transactions)) {
# Check that the ids are unique
unique(c(transactions$id[i:j], transactions$id[z:w])))
#' Reconcile finance sums
#'
#' This function reconciles finance sums by generating all possible combinations of transactions,
#' calculating the sum of the amounts for each combination, and returning a data frame with
#' the sums and corresponding ids.
#'
#' @param amounts A numeric vector of transaction amounts (default: c(10, 20, 30, 40, 50))
#' @return A data frame with two columns: "sum" and "ids"
#' @export
#' @examples
#' finance_reconcile_sums()
#' finance_reconcile_sums(c(5, 10, 15, 20, 25))
finance_reconcile_sums <- function(amounts = c(10, 20, 30, 40, 50)){
# Sample input data frame
transactions <- data.frame( ids = c(1:length(amounts)),
amounts = amounts  )
# Function to generate all possible sum combinations and their corresponding ids
generate_sum_combinations <- function(transactions) {
# Create an empty list to store the output
output <- list()
# Loop through all possible combinations of transactions
for (i in 1:nrow(transactions)) {
for (j in i:nrow(transactions)) {
for (z in j:nrow(transactions)) {
for (w in z:nrow(transactions)) {
# Check that the ids are unique
# Calculate the sum of the amounts for this combination
sum_amount <- sum(transactions$amount[c(i:j,z:w)])
# Add the sum and the corresponding ids to the output list
output[[length(output) + 1]] <- c(sum_amount, paste(transactions$id[c(i:j,z:w)], collapse = "-"))
}
}
}
}
# Convert the output list to a data frame and return it
output_df <- data.frame(t(matrix(unlist(output), ncol = length(output))))
colnames(output_df) <- c("sum", "ids")
return(output_df)
}
# Call the function with the input data frame
output <- generate_sum_combinations(transactions)
return(output)
}
finance_reconcile_sums(amounts = c(1,2,3))
finance_reconcile_sums <- function(amounts = c(10, 20, 30, 40, 50)){
# Sample input data frame
transactions <- data.frame( ids = c(1:length(amounts)),
amounts = amounts  )
# Function to generate all possible sum combinations and their corresponding ids
generate_sum_combinations <- function(transactions) {
# Create an empty list to store the output
output <- list()
# Loop through all possible combinations of transactions
for (i in 1:nrow(transactions)) {
for (j in i:nrow(transactions)) {
for (z in j:nrow(transactions)) {
for (w in z:nrow(transactions)) {
# Check that the ids are unique
# Calculate the sum of the amounts for this combination
sum_amount <- unique(sum(transactions$amount[c(i:j,z:w)]))
# Add the sum and the corresponding ids to the output list
output[[length(output) + 1]] <- c(sum_amount, paste(transactions$id[c(i:j,z:w)], collapse = "-"))
}
}
}
}
# Convert the output list to a data frame and return it
output_df <- data.frame(t(matrix(unlist(output), ncol = length(output))))
colnames(output_df) <- c("sum", "ids")
return(output_df)
}
# Call the function with the input data frame
output <- generate_sum_combinations(transactions)
return(output)
}
finance_reconcile_sums(amounts = c(1,2,3))
i <- 1
j <- 1
z <- 1
w <- 1
amounts = c(10, 20, 30, 40, 50)
sum(transactions$amount[c(i:j,z:w)])
unique(sum(transactions$amount[c(i:j,z:w)])
unique(sum(transactions$amount[c(i:j,z:w)]))
unique(sum(transactions$amount[c(i:j,z:w)]))
c(i:j,z:w)
unique(c(i:j,z:w))
finance_reconcile_sums <- function(amounts = c(10, 20, 30, 40, 50)){
# Sample input data frame
transactions <- data.frame( ids = c(1:length(amounts)),
amounts = amounts  )
# Function to generate all possible sum combinations and their corresponding ids
generate_sum_combinations <- function(transactions) {
# Create an empty list to store the output
output <- list()
# Loop through all possible combinations of transactions
for (i in 1:nrow(transactions)) {
for (j in i:nrow(transactions)) {
for (z in j:nrow(transactions)) {
for (w in z:nrow(transactions)) {
# Check that the ids are unique
# Calculate the sum of the amounts for this combination
sum_amount <- sum(transactions$amount[unique(c(i:j,z:w))])
# Add the sum and the corresponding ids to the output list
output[[length(output) + 1]] <- c(sum_amount, paste(transactions$id[c(i:j,z:w)], collapse = "-"))
}
}
}
}
# Convert the output list to a data frame and return it
output_df <- data.frame(t(matrix(unlist(output), ncol = length(output))))
colnames(output_df) <- c("sum", "ids")
return(output_df)
}
# Call the function with the input data frame
output <- generate_sum_combinations(transactions)
return(output)
}
finance_reconcile_sums(amounts = c(1,2,3))
library(ibeRa)
finance_reconcile_sums(amounts = c(1,2,3))
ibeRa::finance_reconcile_sums(amounts = c(1,2,3))
finance_reconcile_sums <- function(amounts = c(10, 20, 30, 40, 50)){
# Sample input data frame
transactions <- data.frame( ids = c(1:length(amounts)),
amounts = amounts  )
# Function to generate all possible sum combinations and their corresponding ids
generate_sum_combinations <- function(transactions) {
# Create an empty list to store the output
output <- list()
# Loop through all possible combinations of transactions
for (i in 1:nrow(transactions)) {
for (j in i:nrow(transactions)) {
for (z in j:nrow(transactions)) {
for (w in z:nrow(transactions)) {
# Check that the ids are unique
# Calculate the sum of the amounts for this combination
sum_amount <- sum(transactions$amount[unique(c(i:j,z:w))])
# Add the sum and the corresponding ids to the output list
output[[length(output) + 1]] <- c(sum_amount, paste(transactions$id[unique(c(i:j,z:w))], collapse = "-"))
}
}
}
}
# Convert the output list to a data frame and return it
output_df <- data.frame(t(matrix(unlist(output), ncol = length(output))))
colnames(output_df) <- c("sum", "ids")
return(output_df)
}
# Call the function with the input data frame
output <- generate_sum_combinations(transactions)
return(output)
}
ibeRa::finance_reconcile_sums(amounts = c(1,2,3))
ibeRa::finance_reconcile_sums(amounts = c(1,2,3))
library(ibeRa)
library(ibeRa)
ibeRa::finance_reconcile_sums(amounts = c(1,2,3))
ibeRa::finance_reconcile_sums(amounts = c(1,2))
ibeRa::finance_reconcile_sums(amounts = c(1))
library(V10)
